<p align="center">
  <img src= "https://github.com/thrustlang/.github/blob/main/assets/logos/thrustlang-logo-name.png" alt= "logo" style= "width: 2hv; height: 2hv;"> </img>
</p>

# Thrust Programming Language 

## Roadmap > Conventional Programming > Compile Time Code Execution > JIT Dynamic External Type Resolution

This article will briefly discuss how the JIT, together with Cbingen, generates external types for the resolution of external symbols and their subsequent invocation in the JIT.

### JIT Dynamic Types - Generation Type Symbol Resolution

This point is when the JIT begins compiling all the representations it is assigned, provided by the compiler's frontend. This stage maps dynamic symbols found through dynamic libraries provided by the compiler itself (C Runtime and the C Standard Library) or by the programmer via the command line.

This stage searches for each of the functions in all these library representations in the PIE-Dynamic model.

Once it finds them, it adds them to the JIT with the function represented in Rust in the LLVM C API as:

```rust
pub unsafe extern "C" fn LLVMAddGlobalMapping(
    EE: LLVMExecutionEngineRef,
    Global: LLVMValueRef,
    Addr: *mut c_void,
)
```
Cbindgen is like a door, allowing Thrush code generators to access C code and its dependencies.

Just before the JIT generates the code, CBindgen comes into play. It takes the types generated by CBindgen (for example, libc) and generates the IR for each function for its use. These functions are placed in maps, which the JIT will then consult by name at compile time. Once the JIT finds the matching type, it will call the system in charge of generating the symbol.

A dynamic symbol can be obtained in a simple way from [libloading](https://crates.io/crates/libloading) crate in Rust, with the function:

```rust
pub unsafe fn get<T>(&self, symbol: &[u8]) -> Result<Symbol<T>, Error>
```
Once it finds the symbol, it obtains its memory address and passes it to the JIT so that it can integrate it into its global mappings.

Once the entrypoint has been identified, the entrypoint is called for dynamic execution in the JIT and its previous AOT compilation.

The entrypoint execution can be denoted by the LLVM-C API function in Rust:

```rust
pub unsafe extern "C" fn LLVMRunFunction(
    EE: LLVMExecutionEngineRef,
    F: LLVMValueRef,
    NumArgs: c_uint,
    Args: *mut LLVMGenericValueRef,
) -> LLVMGenericValueRef
```
Once the main function, which originates everything, is executed, the value is extracted and passed to the AOT, which normalizes it and integrates it into its final binary compilation.
